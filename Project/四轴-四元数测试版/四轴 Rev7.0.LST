C51 COMPILER V9.00   __REV7_0                                                           02/02/2015 10:24:50 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE __REV7_0
OBJECT MODULE PLACED IN  Rev7.0.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE  Rev7.0.C LARGE OMF2 BROWSE DEBUG TABS(2)

line level    source

   1          //׼ַ                      http://shop112966725.taobao.com
   2          //                                                 STCunio
   3          //Ĵ   ϿƼѧ ϢѧԺ 13   ֧QQ1203933924   
   4          //ֻṩ޼֧,ֹʱ䣺201531,ʱ
   5          //˽ڣڼʱ벻Ҫ򼰱ӲķΧʲôߵչݶ
             -˲
   6          //ͲҪˣҲѧԶԭǸСSTM32ᣬᶼֻܿƵ51
             -Ƭ
   7          //ȫԴڽжοǲϸСĶԼӵаȨ
   8          //ڳϮԼаȨԼֻ˵QNMLGB
   9          
  10          //޸ıӦע⣡
  11          //˳Ż޸ģӹܣ뿪ԴĪ̳ STC 1TƬ 
  12          //ʹñӦѭGNUGPLЭ飡
  13          
  14          //ڱӲհ汾ǻ᲻ڵķ޸Bugĳ
  15          
  16          //رлзиֵ֧Ѽ壺
  17          //                                         ϿƼѧ 09 
  18          //                                         ϿƼѧ Ƕʽʵ οƾ
  19          //                                         ϿƼѧ պѧ߿ѧʵ
  20          
  21          //Ӳ
  22          //:1S/3.7V Ƽ300-650mAh   500mahϵĵƼװڱ
  23          ///:720ı/59MM
  24          //MCU IAP15W4K61S4@28.000MHZ  (B棡A浥ƬԲʺϣ)
  25          //ر˵ĿǰֻʺIAPϵеĵƬIAPƬʹ޸EEPROMдַ
  26          //ǼٶȼƣMPU-6050 
  27          //оƬ:NRF24L01
  28          //MOS:AO3400
  29          //ѹ:BL8530
  30          //3.3Vѹ:ME6219C-33-M5G
  31          //ؿڱ:1K
  32          //ܳߴ:94mm*94mm
  33          
  34          //ʧĵط
  35          //MOSܱõФػŴλãȫӰʹãС᲻ФػС
  36          
  37          //
  38          //̬㣺Ԫ
  39          //˲˲From ¹Դᣩ
  40          //PIDPID ⻷PI,ڻPID
  41          
  42          //ݶ˵
  43          //data 51ƬƬRAMǰ128ֽRAM ACCдٶ
  44          //idata ƬRAMǰ256ֽڵRAM data ָģʽ ʺָ
  45          //pdata ⲿչRAMǰ256ֽڵRAM Ҫ 裡
  46          //xdata ⲿչRAM DPTR
  47          #include <STC15W4K60S4.H>
  48          #include <intrins.h>
  49          #include <NRF24L01.H>
  50          #include <MPU6050.H>
  51          #include <math.h>
  52          #include <STC15W4KPWM.H>
  53          #include <Timer.h>
C51 COMPILER V9.00   __REV7_0                                                           02/02/2015 10:24:50 PAGE 2   

  54          #include <EEPROM.h>
  55          #include <USART.h>
  56          #include <IMU.H>
  57          //******************************************************************************************************
  58          float XE=0,YE=0;                 //ǶΪƯһӲɵģʲֵдEEPROM
             -ӦʹãƯӦ
  59                                           //λǷʱ
  60          unsigned char YM=0;              //ű仯ٶȿƣĻٱ仯ʱʧٷתGG
  61          int ich1=0,ich2=0,ich3=0,ich4=0,ich5=0,ich6=0;         //ߴ/
  62          int speed0=0,speed1=0,speed2=0,speed3=0,V=0;           //ٶȲ
  63          int PWM0=0,PWM1=0,PWM2=0,PWM3=0;  //PWMģĲ
  64          int g_x=0,g_y=0,g_z=0;            //ǽ
  65          unsigned char TxBuf[20]={0};
  66          unsigned char RxBuf[20]={0};  
  67          double PID_x=0,PID_y=0,PID_z=0;  //PID
  68          float FR1=0,FR2=0,FR3=0;         //charתΪfloat
  69          //*****************ǶȲ*************************************************
  70          double Gyro_y=0,Gyro_x=0,Gyro_z=0;        //Yݴ
  71          double Accel_x=0,Accel_y=0,Accel_z=0;     //Xٶֵݴ
  72          double Angle_ax=0,Angle_ay=0,Angle_az=0;  //ɼٶȼļٶ()
  73          double Angle_gy=0,Angle_gx=0,Angle_gz=0;  //ɽٶȼĽ(Ƕ)
  74          double AngleAx=0,AngleAy=0;               //Ǻŷ
  75          double Angle=0,Angley=0;                  //Ԫŷ
  76          double Anglezlate=0;                      //Z
  77          double Ax=0,Ay=0;                         //ңĽǶ
  78          //****************̬PID*********************************************
  79          float Out_PID_X=0,Last_Angle_gx=0;//⻷PI  һ
  80          float Out_XP=60,Out_XI=0.01,ERRORX_Out=0;//⻷P  ⻷I  ⻷
  81          float In_XP=0.5,In_XI=0.01,In_XD=10,ERRORX_In=0;//ڻP  ڻI   ڻD  ڻ
  82          
  83          float Out_PID_Y=0,Last_Angle_gy=0;
  84          float Out_YP=60,Out_YI=0.01,ERRORY_Out=0;
  85          float In_YP=0.5,In_YI=0.01,In_YD=10,ERRORY_In=0;
  86          
  87          float ZP=5.0,ZD=2.0;//ƵP D
  88            
  89          void Angle_Calculate() interrupt 1 
  90          { 
  91   1        if(YM<RxBuf[4]&&(RxBuf[4]-YM)<=2){YM++;YM++;}
  92   1        else if(YM>RxBuf[4]&&(YM-RxBuf[4])<=2){YM--;YM--;}  //ֹű仯ʧ
  93   1        else {YM=RxBuf[4];}
  94   1        Accel_y= GetData(ACCEL_YOUT_H); //ȡ6050
  95   1        Accel_x= GetData(ACCEL_XOUT_H);      
  96   1        Accel_z= GetData(ACCEL_ZOUT_H);      
  97   1        Gyro_x = GetData(GYRO_XOUT_H)-g_x;
  98   1        Gyro_y = GetData(GYRO_YOUT_H)-g_y;
  99   1        Gyro_z = GetData(GYRO_ZOUT_H)-g_z;  
 100   1        Last_Angle_gx=Angle_gx;   //һνٶ
 101   1        Last_Angle_gy=Angle_gy; 
 102   1        Angle_ax=(Accel_x)/8192;  //ٶȴ
 103   1        Angle_az=(Accel_z)/8192;  //ٶ +-4g/S
 104   1        Angle_ay=(Accel_y)/8192;  //תϵ8192LSB/g
 105   1        Angle_gx=(Gyro_x)/65.5;   //Ǵ
 106   1        Angle_gy=(Gyro_y)/65.5;   // +-500/S
 107   1        Angle_gz=(Gyro_z)/65.5;   //תϵ65.5LSB/
 108   1      //***********************************Ԫ***********************************
 109   1        IMUupdate(Angle_gx*0.0174533,Angle_gy*0.0174533,Angle_gz*0.0174533,Angle_ax,Angle_ay,Angle_az);
 110   1        //0.174533ΪPI/180 ĿǽǶת
 111   1      //********************ǺֱӽԹȽԪ㾫׼********************
 112   1        AngleAx=atan(Angle_ax/sqrt(Angle_ay*Angle_ay+Angle_az*Angle_az))*57.2957795f; //180/PI Ŀ
             -תǶ
 113   1        AngleAy=atan(Angle_ay/sqrt(Angle_ax*Angle_ax+Angle_az*Angle_az))*57.2957795f;
C51 COMPILER V9.00   __REV7_0                                                           02/02/2015 10:24:50 PAGE 3   

 114   1      //**************Xָ***********************************************************
 115   1        FR1=((float)RxBuf[1]-128)/10; //charתΪfloatԱ
 116   1        
 117   1        Ax=Angle-FR1;      //ǶȿǶ
 118   1        
 119   1        if(YM>20)
 120   1        {
 121   2        ERRORX_Out+=Ax;//⻷(Сĳֵʱ)
 122   2        }
 123   1        else
 124   1        {
 125   2          ERRORX_Out=0; //Сڶֵʱֵ
 126   2        }
 127   1        if(ERRORX_Out>500){ERRORX_Out=500;}
 128   1        else if(ERRORX_Out<-500){ERRORX_Out=-500;}//޷
 129   1        
 130   1        Out_PID_X=Ax*Out_XP+ERRORX_Out*Out_XI;//⻷PI
 131   1        
 132   1        if(YM>20)
 133   1        {
 134   2        ERRORX_In+=(Angle_gy-Out_PID_X);  //ڻ(Сĳֵʱ)
 135   2        } 
 136   1        else
 137   1        {
 138   2          ERRORX_In=0; //Сڶֵʱֵ
 139   2        } 
 140   1        if(ERRORX_In>500){ERRORX_In=500;}
 141   1        else if(ERRORX_In<-500){ERRORX_In=-500;}//޷
 142   1        
 143   1        PID_x=(Angle_gy+Out_PID_X)*In_XP+ERRORX_In*In_XI+(Angle_gy-Last_Angle_gy)*In_XD;//ڻPID
 144   1        
 145   1        if(PID_x>1000){PID_x=1000;}  //޷
 146   1        if(PID_x<-1000){PID_x=-1000;}
 147   1        
 148   1        speed0=0-PID_x,speed2=0+PID_x;
 149   1      //**************Yָ**************************************************
 150   1        FR2=((float)RxBuf[2]-128)/10; //charתΪfloatԱ
 151   1        
 152   1        Ay=Angley+FR2;      //ǶȿǶ
 153   1        
 154   1        if(YM>20)
 155   1        {
 156   2        ERRORY_Out+=Ay;//⻷(Сĳֵʱ)
 157   2        }
 158   1        else
 159   1        {
 160   2          ERRORY_Out=0; //Сڶֵʱֵ
 161   2        } 
 162   1        if(ERRORY_Out>500){ERRORY_Out=500;}
 163   1        else if(ERRORY_Out<-500){ERRORY_Out=-500;}//޷
 164   1        
 165   1        Out_PID_Y=Ay*Out_YP+ERRORY_Out*Out_YI;//⻷PI
 166   1        
 167   1        if(YM>20)
 168   1        {
 169   2        ERRORY_In+=(Angle_gx-Out_PID_Y);  //ڻ(Сĳֵʱ)
 170   2        }   
 171   1        else
 172   1        {
 173   2          ERRORY_In=0; //Сڶֵʱֵ
 174   2        } 
 175   1        if(ERRORY_In>500){ERRORY_In=500;}
C51 COMPILER V9.00   __REV7_0                                                           02/02/2015 10:24:50 PAGE 4   

 176   1        else if(ERRORY_In<-500){ERRORY_In=-500;}//޷
 177   1        
 178   1        PID_y=(Angle_gx+Out_PID_Y)*In_YP+ERRORY_In*In_YI+(Angle_gx-Last_Angle_gx)*In_YD;//ڻPID
 179   1        
 180   1        if(PID_y>1000){PID_y=1000;}  //޷
 181   1        if(PID_y<-1000){PID_y=-1000;}
 182   1        
 183   1        speed3=0+PID_y,speed1=0-PID_y;//صٶȲ
 184   1      //**************Zָ(ZûҪϴPID)*****************************  
 185   1        FR3=((float)RxBuf[3]-128)/7;
 186   1        Angle_gz-=FR3; 
 187   1        PID_z=(Angle_gz)*ZP+(Angle_gz-Anglezlate)*ZD;
 188   1        Anglezlate=Angle_gz;
 189   1        speed0=speed0+PID_z,speed2=speed2+PID_z;
 190   1        speed1=speed1-PID_z,speed3=speed3-PID_z;
 191   1      //*****************ڼߴ***************************************************
 192   1        ich1=Ax;
 193   1        ich2=Ay;
 194   1        ich3=AngleAx;                 //˴ɷ6λҪʲôڴ˴޸ļ
 195   1        ich4=AngleAy;
 196   1        ich5=0;
 197   1        ich6=0;
 198   1      //**************ٶȲPWMģ*************************************************  
 199   1        PWM0=(1000-YM*4+speed0);
 200   1        if(PWM0>1000){PWM0=1000;}    //ٶȲƣֹPWMΧ0-1000
 201   1        else if(PWM0<0){PWM0=0;}
 202   1      
 203   1        PWM1=(1000-YM*4+speed1);
 204   1        if(PWM1>1000){PWM1=1000;}
 205   1        else if(PWM1<0){PWM1=0;}
 206   1      
 207   1        PWM2=(1000-YM*4+speed2);
 208   1        if(PWM2>1000){PWM2=1000;}
 209   1        else if(PWM2<0){PWM2=0;}
 210   1        
 211   1        PWM3=(1000-YM*4+speed3);
 212   1        if(PWM3>1000){PWM3=1000;}
 213   1        else if(PWM3<0){PWM3=0;}
 214   1        if(YM>=10)
 215   1        {PWM(PWM1,PWM2,PWM0,PWM3);}//1203
 216   1        else
 217   1        {PWM(1000,1000,1000,1000);}
 218   1      } 
 219          void main()
 220          {
 221   1      PWMGO();//ʼPWM
 222   1      IAPRead();//ȡǾ
 223   1      InitMPU6050();//ʼMPU-6050
 224   1      Usart_Init();//ʼ
 225   1      init_NRF24L01();//ʼģ
 226   1      Time0_Init();//ʼʱ
 227   1      RxBuf[1]=128;
 228   1      RxBuf[2]=128;
 229   1      RxBuf[3]=128;
 230   1      RxBuf[4]=0;
 231   1        SetRX_Mode();
 232   1      while(1)
 233   1      {    
 234   2              Delay(750);
 235   2              nRF24L01_RxPacket(RxBuf);
 236   2              if(RxBuf[5]==1) {IAPWrite();RxBuf[5]=0;}
 237   2              if(RxBuf[6]==1) {XE=Ax;YE=Ay;RxBuf[6]=0;}
C51 COMPILER V9.00   __REV7_0                                                           02/02/2015 10:24:50 PAGE 5   

 238   2              //Send(ich1,ich2,ich3,ich4,ich5,ich6);  //ڷ  λȡעͱ䣡עͱ
             -Ϊ˼Сңʱ
 239   2      }
 240   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3302    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    265    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
